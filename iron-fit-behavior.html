<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">

<script>
/**
Polymer.IronFitBehavior fits an element in another element using `max-height` and `max-width`, and
optionally centers it in the window or another element.

The element will only be sized and/or positioned if it has not already been sized and/or positioned
by CSS.

CSS properties               | Action
-----------------------------|-------------------------------------------
`position` set               | Element is not centered horizontally or vertically
`top` or `bottom` set        | Element is not vertically centered
`left` or `right` set        | Element is not horizontally centered
`max-height` or `height` set | Element respects `max-height` or `height`
`max-width` or `width` set   | Element respects `max-width` or `width`

@demo demo/index.html
@polymerBehavior
*/

  Polymer.IronFitBehavior = {

    properties: {

      /**
       * The element that will receive a `max-height`/`width`. By default it is the same as `this`,
       * but it can be set to a child element. This is useful, for example, for implementing a
       * scrolling region inside the element.
       * @type {!Element}
       */
      sizingTarget: {
        type: Object,
        value: function() {
          return this;
        }
      },

      /**
       * The element to fit `this` into.
       */
      fitInto: {
        type: Object,
        value: window
      },

      /**
       * Will position the element around the positionTarget without overlapping it.
       */
      autoPosition: {
        type: Boolean,
        observer: '_updatePosition'
      },

      /**
       * The element that should be used to position the element.
       */
      positionTarget: {
        type: Node,
        observer: '_updatePosition'
      },

      /**
       * The orientation against which to align the element horizontally
       * relative to the `positionTarget`. Possible values are left, right.
       */
      horizontalAlign: {
        type: String,
        observer: '_updatePosition'
      },

      /**
       * The orientation against which to align the element vertically
       * relative to the `positionTarget`. Possible values are top, bottom.
       */
      verticalAlign: {
        type: String,
        observer: '_updatePosition'
      },

      /**
       * A pixel value that will be added to the position calculated for the
       * given `horizontalAlign`, in the direction of alignment. You can think
       * of it as increasing or decreasing the distance to the side of the
       * screen given by `horizontalAlign`.
       *
       * If `horizontalAlign` is "left", this offset will increase or decrease
       * the distance to the left side of the screen: a negative offset will
       * move the dropdown to the left; a positive one, to the right.
       *
       * Conversely if `horizontalAlign` is "right", this offset will increase
       * or decrease the distance to the right side of the screen: a negative
       * offset will move the dropdown to the right; a positive one, to the left.
       */
      horizontalOffset: {
        type: Number,
        value: 0,
        notify: true,
        observer: '_updatePosition'
      },

      /**
       * A pixel value that will be added to the position calculated for the
       * given `verticalAlign`, in the direction of alignment. You can think
       * of it as increasing or decreasing the distance to the side of the
       * screen given by `verticalAlign`.
       *
       * If `verticalAlign` is "top", this offset will increase or decrease
       * the distance to the top side of the screen: a negative offset will
       * move the dropdown upwards; a positive one, downwards.
       *
       * Conversely if `verticalAlign` is "bottom", this offset will increase
       * or decrease the distance to the bottom side of the screen: a negative
       * offset will move the dropdown downwards; a positive one, upwards.
       */
      verticalOffset: {
        type: Number,
        value: 0,
        notify: true,
        observer: '_updatePosition'
      },

      /**
       * Set to true to auto-fit on attach.
       */
      autoFitOnAttach: {
        type: Boolean,
        value: false
      },

      /** @type {?Object} */
      _fitInfo: {
        type: Object
      }
    },

    get _fitWidth() {
      var fitWidth;
      if (this.fitInto === window) {
        fitWidth = this.fitInto.innerWidth;
      } else {
        fitWidth = this.fitInto.getBoundingClientRect().width;
      }
      return fitWidth;
    },

    get _fitHeight() {
      var fitHeight;
      if (this.fitInto === window) {
        fitHeight = this.fitInto.innerHeight;
      } else {
        fitHeight = this.fitInto.getBoundingClientRect().height;
      }
      return fitHeight;
    },

    get _fitLeft() {
      var fitLeft;
      if (this.fitInto === window) {
        fitLeft = 0;
      } else {
        fitLeft = this.fitInto.getBoundingClientRect().left;
      }
      return fitLeft;
    },

    get _fitTop() {
      var fitTop;
      if (this.fitInto === window) {
        fitTop = 0;
      } else {
        fitTop = this.fitInto.getBoundingClientRect().top;
      }
      return fitTop;
    },

    /**
     * The element that should be used to position the element when
     * it opens, if no position target is configured.
     */
    get _defaultPositionTarget() {
      var parent = Polymer.dom(this).parentNode;

      if (parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        parent = parent.host;
      }

      return parent;
    },

    /**
     * The horizontal align value, accounting for the RTL/LTR text direction.
     */
    get _localeHorizontalAlign() {
      if (!this._isRTL || !this.horizontalAlign) {
        return this.horizontalAlign;
      }
      // In RTL, "left" becomes "right".
      return this.horizontalAlign === 'right' ? 'left' : 'right';
    },

    attached: function() {
      // Memoize this to avoid expensive calculations & relayouts.
      this._isRTL = window.getComputedStyle(this).direction == 'rtl';
      this.positionTarget = this.positionTarget || this._defaultPositionTarget;
      if (this.autoFitOnAttach) {
        if (window.getComputedStyle(this).display === 'none') {
          setTimeout(function() {
            this.fit();
          }.bind(this));
        } else {
          this.fit();
        }
      }
    },

    /**
     * Fits and optionally centers the element into the window, or `fitInfo` if specified.
     */
    fit: function() {
      this._discoverInfo();
      this.position();
      this.constrain();
      this.center();
    },

    /**
     * Memoize information needed to position and size the target element.
     */
    _discoverInfo: function() {
      if (this._fitInfo) {
        return;
      }
      var target = window.getComputedStyle(this);
      var sizer = window.getComputedStyle(this.sizingTarget);
      this._fitInfo = {
        inlineStyle: {
          top: this.style.top || '',
          left: this.style.left || '',
          bottom: this.style.bottom || '',
          right: this.style.right || '',
          position: this.style.position || ''
        },
        positionedBy: {
          vertically: target.top !== 'auto' ? 'top' : (target.bottom !== 'auto' ?
            'bottom' : this.verticalAlign),
          horizontally: target.left !== 'auto' ? 'left' : (target.right !== 'auto' ?
            'right' : this._localeHorizontalAlign)
        },
        thisRect: this.getBoundingClientRect(),
        sizedBy: {
          height: sizer.maxHeight !== 'none',
          width: sizer.maxWidth !== 'none'
        },
        margin: {
          top: parseInt(target.marginTop, 10) || 0,
          right: parseInt(target.marginRight, 10) || 0,
          bottom: parseInt(target.marginBottom, 10) || 0,
          left: parseInt(target.marginLeft, 10) || 0
        }
      };
    },

    /**
     * Resets the target element's position and size constraints, and clear
     * the memoized data.
     */
    resetFit: function() {
      if (!this._fitInfo || !this._fitInfo.sizedBy.width) {
        this.sizingTarget.style.maxWidth = '';
      }
      if (!this._fitInfo || !this._fitInfo.sizedBy.height) {
        this.sizingTarget.style.maxHeight = '';
      }

      this.style.top = this._fitInfo ? this._fitInfo.inlineStyle.top : '';
      this.style.left = this._fitInfo ? this._fitInfo.inlineStyle.left : '';
      this.style.bottom = this._fitInfo ? this._fitInfo.inlineStyle.bottom : '';
      this.style.right = this._fitInfo ? this._fitInfo.inlineStyle.right : '';
      this.style.position = this._fitInfo ? this._fitInfo.inlineStyle.position : '';

      this._fitInfo = null;
    },

    /**
     * Equivalent to calling `resetFit()` and `fit()`. Useful to call this after the element,
     * the window, or the `fitInfo` element has been resized.
     */
    refit: function() {
      this.resetFit();
      this.fit();
    },

    /**
     * Positions the element according to horizontalAlign, verticalAlign.
     */
    position: function() {
      if (!this.horizontalAlign && !this.verticalAlign && !this.autoPosition) {
        // needs to be centered, and it is done after constrain.
        return;
      }
      this.style.position = 'fixed';
      var positionRect = this._getNormalizedPositionRect();

      if (this.autoPosition) {
        // Set to 0, 0 in order to discover any offset caused by parent stacking contexts.
        this.style.left = '0px';
        this.style.top = '0px';
        var rect = this.getBoundingClientRect();
        var point = this._getAutopositionPoint(rect, positionRect);
        this.style.left = point.left + 'px';
        this.style.top = point.top + 'px';
        return;
      }

      var hAlign = this._fitInfo.positionedBy.horizontally;
      var vAlign = this._fitInfo.positionedBy.vertically;
      // Set to 0, 0 in order to discover any offset caused by parent stacking contexts.
      if (hAlign) {
        this.style[hAlign] = '0px';
      }
      if (vAlign) {
        this.style[vAlign] = '0px';
      }
      var rect = this.getBoundingClientRect();

      if (hAlign) {
        var horizontalValue = this._horizontalAlignTargetValue(rect, positionRect, hAlign === 'right');
        this.style[hAlign] = horizontalValue + 'px';
      }
      if (vAlign) {
        var verticalValue = this._verticalAlignTargetValue(rect, positionRect, vAlign === 'bottom');
        this.style[vAlign] = verticalValue + 'px';
      }

    },

    /**
     * Constrains the size of the element to the window or `fitInfo` by setting `max-height`
     * and/or `max-width`.
     */
    constrain: function() {
      var info = this._fitInfo;
      if (!this.autoPosition) {
        // position at (0px, 0px) if not already positioned, so we can measure the natural size.
        if (!info.positionedBy.vertically) {
          this.style.top = '0px';
        }
        if (!info.positionedBy.horizontally) {
          this.style.left = '0px';
        }
        if (!info.positionedBy.vertically || !info.positionedBy.horizontally) {
          // need position:fixed to properly size the element
          this.style.position = 'fixed';
        }
      }

      // need border-box for margin/padding
      this.sizingTarget.style.boxSizing = 'border-box';
      // constrain the width and height if not already set
      var rect = this.getBoundingClientRect();
      if (!info.sizedBy.height) {
        this._sizeDimension(rect, 'Height');
      }
      if (!info.sizedBy.width) {
        this._sizeDimension(rect, 'Width');
      }
    },

    _sizeDimension: function(rect, extent) {
      var info = this._fitInfo;
      var positionedBy = extent === 'Width' ? info.positionedBy.horizontally : info.positionedBy.vertically;
      var max = extent === 'Width' ? this._fitWidth : this._fitHeight;
      var start = extent === 'Width' ? 'left' : 'top';
      var end = extent === 'Width' ? 'right' : 'bottom';
      var flip = (positionedBy === end);

      var offset = flip ? max - rect[end] : rect[start];
      var margin = info.margin[flip ? start : end];
      var offsetExtent = 'offset' + extent;
      var sizingOffset = this[offsetExtent] - this.sizingTarget[offsetExtent];
      this.sizingTarget.style['max' + extent] = (max - margin - offset - sizingOffset) + 'px';
    },

    /**
     * Centers horizontally and vertically if not already positioned. This also sets
     * `position:fixed`.
     */
    center: function() {
      var positionedBy = this._fitInfo.positionedBy;
      if (this.autoPosition || (positionedBy.vertically && positionedBy.horizontally)) {
        // Already positioned.
        return;
      }
      // Need position:fixed to center
      this.style.position = 'fixed';
      // Take into account the offset caused by parents that create stacking
      // contexts (e.g. with transform: translate3d). Translate to 0,0 and
      // measure the bounding rect.
      if (!positionedBy.vertically) {
        this.style.top = '0px';
      }
      if (!positionedBy.horizontally) {
        this.style.left = '0px';
      }
      // It will take in consideration margins and transforms
      var rect = this.getBoundingClientRect();
      if (!positionedBy.vertically) {
        var top = this._fitTop - rect.top + (this._fitHeight - rect.height) / 2;
        this.style.top = top + 'px';
      }
      if (!positionedBy.horizontally) {
        var left = this._fitLeft - rect.left + (this._fitWidth - rect.width) / 2;
        this.style.left = left + 'px';
      }
    },

    /**
     * The horizontal offset value used to position the element.
     * @param {ClientRect} rect
     * @param {ClientRect} positionRect
     * @param {boolean=} fromRight
     * @return {number} pixels
     * @private
     */
    _horizontalAlignTargetValue: function(rect, positionRect, fromRight) {
      var target;
      if (fromRight) {
        target = document.documentElement.offsetWidth - positionRect.right - (this._fitWidth - rect.right);
      } else {
        target = positionRect.left - rect.left;
      }
      target += this.horizontalOffset;

      return Math.max(target, 0);
    },

    /**
     * The vertical offset value used to position the element.
     * @param {ClientRect} rect
     * @param {ClientRect} positionRect
     * @param {boolean=} fromBottom
     * @return {number} pixels
     * @private
     */
    _verticalAlignTargetValue: function(rect, positionRect, fromBottom) {
      var target;
      if (fromBottom) {
        target = document.documentElement.offsetHeight - positionRect.bottom - (this._fitHeight - rect.bottom);
      } else {
        target = positionRect.top - rect.top;
      }
      target += this.verticalOffset;

      return Math.max(target, 0);
    },

    _updatePosition: function() {
      if (this.isAttached) {
        this.refit();
      }
    },

    _getAutopositionPoint: function(rect, positionRect) {
      var maxWidth = document.documentElement.offsetWidth;
      var maxHeight = document.documentElement.offsetHeight;
      var points = [{
        left: positionRect.left + this.horizontalOffset, // left aligned to left
        top: positionRect.bottom + this.verticalOffset // top aligned to bottom
      }, {
        left: positionRect.right - this.horizontalOffset - rect.width, // right aligned to right
        top: positionRect.bottom + this.verticalOffset // top aligned to bottom
      }, {
        left: positionRect.left - this.horizontalOffset - rect.width, // right aligned to left
        top: positionRect.top + this.verticalOffset // top aligned to top
      }, {
        left: positionRect.right + this.horizontalOffset, // left aligned to right
        top: positionRect.top + this.verticalOffset // top aligned to top
      }, {
        left: positionRect.left + this.horizontalOffset, // left aligned to left
        top: positionRect.top - this.verticalOffset - rect.height // bottom aligned to top
      }, {
        left: positionRect.right - this.horizontalOffset - rect.width, // right aligned to right
        top: positionRect.top - this.verticalOffset - rect.height // bottom aligned to top
      }, {
        left: positionRect.left - this.horizontalOffset - rect.width, // right aligned to left
        top: positionRect.bottom - this.verticalOffset - rect.height // bottom aligned to bottom
      }, {
        left: positionRect.right + this.horizontalOffset, // left aligned to right
        top: positionRect.bottom - this.verticalOffset - rect.height // bottom aligned to bottom
      }];

      // Search for the point that minimizes the cropped area.
      var point;
      for (var i = 0; i < points.length; i++) {
        var p = points[i];
        var croppedLeft = Math.max(0, -p.left);
        var croppedRight = Math.max(0, p.left + rect.width - maxWidth);
        var croppedAreaWidth = (croppedLeft + croppedRight) * rect.height;
        var croppedTop = Math.max(0, -p.top);
        var croppedBottom = Math.max(0, p.top + rect.height - maxHeight);
        var croppedAreaHeight = (croppedTop + croppedBottom) * rect.width;
        p.croppedArea = croppedAreaWidth + croppedAreaHeight;
        if (!point || point.croppedArea > p.croppedArea) {
          point = p;
        }
      }
      // If it crops the whole element, better to position it at top-left
      var area = rect.width * rect.height;
      if (point.croppedArea >= area) {
        point.left = positionRect.left + this.horizontalOffset;
        point.top = positionRect.top + this.verticalOffset;
      }
      return point;
    },

    _getNormalizedPositionRect: function() {
      if ([document.body, document.documentElement, window].indexOf(this.positionTarget) !== -1) {
        return {
          top: 0,
          left: 0,
          width: window.innerWidth,
          height: window.innerHeight,
          bottom: window.innerHeight,
          right: window.innerWidth
        };
      }
      return this.positionTarget.getBoundingClientRect();
    }

  };
</script>
